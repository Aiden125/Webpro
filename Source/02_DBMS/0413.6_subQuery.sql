-- [VI] SUB QUERY ; QUERY안에 QUERY가 내포



-- ★ 1. 서브 쿼리 개념(필요성)
-- 서브쿼리를 써야할 때 예시 : 급여제일 많이 받는 사람의 사번, 이름, 직책, 급여
SELECT MAX(SAL) FROM EMP;
SELECT EMPNO, MAX(SAL) FROM EMP GROUP BY EMPNO;

SELECT MAX(SAL) FROM EMP; --서브쿼리
SELECT EMPNO, ENAME, JOB, SAL
    FROM EMP
    WHERE SAL = (SELECT MAX(SAL) FROM EMP); -- 메인쿼리(서브쿼리는 괄호로 묶여있어야 함)


-- 서브쿼리 종류(1) 단일행 서브쿼리 - 서브쿼리를 실행했을 때 결과가 단일행 일 때 : =, >, >=, <, <=, != 등등 부등호 사용가능

    -- EX. SCOTT이 근무하는 부서이름 출력
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브쿼리
SELECT DNAME
    FROM DEPT
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'); --메인쿼리
    
SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT';


-- 서브쿼리 종류(2) 다중행 서브쿼리(서브쿼리 결과 2행이상) : IN. ANY, ALL, EXISTS
    -- EX. JOB이 MANAGER인 사람의 부서이름
    SELECT DEPTNO FROM EMP WHERE JOB='MANAGER'; -- 서브쿼리
    SELECT DNAME FROM DEPT
        WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB='MANAGER');



--------------------------------------------------------------------------------


-- ★ 2. 단일행 서브쿼리
    -- 아래 문제 전처리(SCOTT 부서번호:20, 근무지:DALLAS)
SELECT E.DEPTNO, LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT';

-- SCOTT과 동일한 부서번호 추가를 위해 인서트 하는데, 부모가 되는 DEPT부터 해야지 제대로 설정됨
INSERT INTO DEPT VALUES(50, 'IT', 'DALLAS');
INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (9999, '홍길덩', 50); --EMP뒤에 저렇게 세개만 넣으면 저 데이터만 넣겠다는 것. 나머지는 NULL로 자동설정

    -- EX. SCOTT과 같은 부서인 사람의 이름과 급여 출력
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브쿼리
SELECT ENAME, SAL
    FROM EMP
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT') AND ENAME!='SCOTT'; --메인 쿼리

    -- EX. SCOTT과 같은 근무지인 사람의 이름과 급여 출력
SELECT LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT'; -- 서브쿼리
SELECT ENAME, SAL
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
        AND LOC = (SELECT LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT')
        AND ENAME!='SCOTT';
    ROLLBACK; --가장 최근에 한 DML 취소(DML-데이터추가,수정,삭제 등을 취소)
    

    -- EX. 최초입사일과 최초입사한 사람이름
SELECT MIN(HIREDATE) FROM EMP; -- 단일행 서브쿼리
SELECT ENAME, HIREDATE
    FROM EMP
    WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP); --메인쿼리
    
    
    -- EX. 최근입사일과 최근입사한 사람이름
SELECT MAX(HIREDATE) FROM EMP; -- 단일행 서브쿼리
SELECT ENAME, HIREDATE
    FROM EMP
    WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP); --메인쿼리
    
    
    -- EX. 최초입사일과 최초입사한 사람이름, 최근입사일과 최근입사한 사람이름
    -- 셀렉트문에 서브쿼리 넣어서 하는경우
SELECT
    (SELECT MAX(HIREDATE) FROM EMP) LAST,
    (SELECT ENAME FROM EMP
    WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP)) LASTMAN,
    (SELECT MIN(HIREDATE) FROM EMP) FIRST,
    (SELECT ENAME FROM EMP
    WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP)) FIRSTMAN
    FROM DUAL;
    
    -- JOIN 이용해서 하는 경우
    SELECT E1.HIREDATE, E1.ENAME, E2.HIREDATE, E2.ENAME
    FROM EMP E1, EMP E2
    WHERE E1.HIREDATE = (SELECT MIN(HIREDATE) FROM EMP)
    AND E2.HIREDATE = (SELECT MAX(HIREDATE) FROM EMP);

    -- EX. SCOTT과 같은 부서에 근무하는 사람들의 급여합
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브쿼리
SELECT SUM(SAL)
    FROM EMP
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'); --메인쿼리
    
    -- EX. SCOTT과 동일한 직책(JOB)을 가진 사원의 모든 필드
SELECT JOB FROM EMP WHERE ENAME='SCOTT';
SELECT * FROM EMP WHERE JOB=(SELECT JOB FROM EMP WHERE ENAME='SCOTT');

    -- EX. DALLAS에서 근무하는 사원의 이름, 부서번호
SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS'; -- 서브쿼리
SELECT ENAME, DEPTNO
    FROM EMP
    WHERE DEPTNO=(SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS'); -- 메인쿼리

    -- EX. 'KING'이 직속상사인 사원의 이름과 급여
SELECT EMPNO FROM EMP WHERE ENAME='KING'; -- 서브쿼리
SELECT ENAME, SAL
    FROM EMP
    WHERE MGR=(SELECT EMPNO FROM EMP WHERE ENAME='KING'); -- 메인쿼리
    
SELECT W.ENAME, W.SAL
    FROM EMP W, EMP M
    WHERE W.MGR=M.EMPNO AND M.ENAME='KING';


    -- EX1. 평균 급여 이하로 받는 사원의 이름과 급여를 출력
SELECT AVG(SAL) FROM EMP;
SELECT ENAME, SAL
    FROM EMP
    WHERE SAL<=(SELECT AVG(SAL) FROM EMP)
    ORDER BY SAL;

    -- EX2. 평균급여 이하로 받는 사원의 이름, 급여, 평균급여 출력
SELECT ENAME, SAL, ROUND((SELECT AVG(SAL) FROM EMP))
    FROM EMP
    WHERE SAL <= (SELECT AVG(SAL) FROM EMP);
    
    -- EX3. 평균급여 이하로 받는 사원의 이름, 급여, 평균과 차이 출력
SELECT AVG(SAL) FROM EMP;
SELECT ENAME, SAL, ROUND(ABS(((SELECT AVG(SAL) FROM EMP)-SAL))) GAP
    FROM EMP
    WHERE SAL<=(SELECT AVG(SAL) FROM EMP);


-- 단일행 다중열 서브쿼리 : SCOTT과 JOB, DEPTNO가 같은 직원의 모든 필드 출력
-- 서브쿼리가 다중열이이면 WHERE 조건에 똑같이 괄호로 묶어주기. 밑에서 (JOB, DEPTNO) 한 것처럼.(순서도 일치시켜야함)
SELECT JOB, DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브쿼리(단일행 다중열)
SELECT * FROM EMP
    WHERE (JOB, DEPTNO) =(SELECT JOB, DEPTNO FROM EMP WHERE ENAME='SCOTT')
    AND ENAME!='SCOTT';
    
    


-- ★ 총 연습문제
--1. 사원테이블에서 가장 먼저 입사한 사람의 이름, 급여, 입사일
SELECT MIN(HIREDATE) FROM EMP;
SELECT ENAME, SAL, HIREDATE
    FROM EMP
    WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP);
    
-- 2. 회사에서 가장 급여가 적은 사람의 이름, 급여
SELECT MIN(SAL) FROM EMP;
SELECT ENAME, SAL
    FROM EMP
    WHERE SAL = (SELECT MIN(SAL) FROM EMP);
    
-- 3. 회사 평균보다 급여를 많이 받는 사람의 이름, 급여, 부서코드
SELECT AVG(SAL) FROM EMP;
SELECT ENAME, SAL, DEPTNO
    FROM EMP
    WHERE SAL>(SELECT AVG(SAL) FROM EMP);

--4. 회사 평균 이하의 급여를 받는 사람의 이름, 급여, 부서명
SELECT AVG(SAL) FROM EMP;
SELECT ENAME, SAL, DNAME
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND SAL < (SELECT AVG(SAL) FROM EMP);
    
--5. SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급
SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT';
SELECT ENAME, SAL, HIREDATE, GRADE
    FROM EMP, SALGRADE
    WHERE SAL BETWEEN LOSAL AND HISAL
    AND HIREDATE<(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT');

--6. 5번(SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급)에 부서명 추가하고 급여가 큰 순 정렬
SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT';
SELECT DNAME, ENAME, SAL, HIREDATE, GRADE
    FROM EMP E, DEPT D, SALGRADE
    WHERE E.DEPTNO=D.DEPTNO
    AND SAL BETWEEN LOSAL AND HISAL
    AND HIREDATE<(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT')
    ORDER BY SAL DESC;

--7. BLAKE 보다 급여가 많은 사원들의 사번, 이름, 급여
SELECT SAL FROM EMP WHERE ENAME='BLAKE';
SELECT EMPNO, ENAME, SAL
    FROM EMP
    WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='BLAKE');
    
--8. MILLER보다 늦게 입사한 사원의 사번, 이름, 입사일
SELECT HIREDATE FROM EMP WHERE ENAME='MILLER';
SELECT EMPNO, ENAME, HIREDATE
    FROM EMP
    WHERE HIREDATE>(SELECT HIREDATE FROM EMP WHERE ENAME='MILLER');
    
--9. 사원전체 평균 급여보다 급여가 많은 사원들의 사번, 이름, 급여
SELECT AVG(SAL) FROM EMP;
SELECT EMPNO, ENAME, SAL
    FROM EMP
    WHERE SAL > (SELECT AVG(SAL) FROM EMP);

--10. CLARK와 같은 부서번호이며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원의 사번, 이름, 급여
SELECT DEPTNO FROM EMP WHERE ENAME='CLARK';
SELECT SAL FROM EMP WHERE EMPNO='7698';
SELECT EMPNO, ENAME, SAL
    FROM EMP
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='CLARK')
        AND SAL > (SELECT SAL FROM EMP WHERE EMPNO='7698');

--11.  응용심화. CLARK와 같은 부서명이며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원의 사번, 이름, 급여
SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='CLARK';
SELECT SAL FROM EMP WHERE EMPNO='7698';
SELECT EMPNO, ENAME, SAL
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
        AND DNAME = (SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='CLARK')
        AND SAL > (SELECT SAL FROM EMP WHERE EMPNO='7698');
    
--12. BLAKE와 같은 부서에 있는 모든 사원의 이름과 입사일자
SELECT DEPTNO FROM EMP WHERE ENAME='BLAKE';
SELECT ENAME, HIREDATE
    FROM EMP
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='BLAKE');

--13. 평균 급여 이상을 받는 모든 종업원에 대해서 사원번호와 이름 단 급여가 많은 순으로 출력)
SELECT AVG(SAL) FROM EMP;
SELECT EMPNO, ENAME
    FROM EMP
    WHERE SAL > (SELECT AVG(SAL) FROM EMP)
    ORDER BY SAL DESC;



--------------------------------------------------------------------------------


-- ★ 3. 다중행 서브쿼리
-- (1) IN : 서브쿼리 결과 중 하나라도 일치하면 참
    -- EX. 부서별로 입사일이 가장 늦은 사람의 이름, 입사일, 부서번호
SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO; -- 서브쿼리(다중행, 다중열)
SELECT ENAME, HIREDATE, DEPTNO
    FROM EMP
    WHERE (DEPTNO, HIREDATE) IN (SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO); --메인쿼리
    
    -- EX. 급여 3000이상 받는 사원이 소속된 부서에서 근무하는 사원의 모든 필드
SELECT DEPTNO FROM EMP WHERE SAL>=3000;
SELECT *
    FROM EMP
    WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE SAL>=3000);
    

-- (2) ALL : 해당 값 안에서 가장 큰 것(BUT, 대부분 단일행 서브쿼리로 만들어서 쓰는게 편함)
    -- EX. 30번 부서 급여들 모두보다 큰 경우의 모든 필드= 30번 부서 최대 급여보다 큰 경우
SELECT SAL FROM EMP WHERE DEPTNO=30; -- 서브쿼리(다중행)
SELECT * FROM EMP WHERE SAL > ALL(SELECT SAL FROM EMP WHERE DEPTNO=30);

-- 위의 다중행 서브쿼리를 단일행 서브쿼리로 만든 것
SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30;
SELECT *
    FROM EMP
    WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);



-- (3) ANY=SOME ; 서브쿼리 결과가 하나라도 만족하면 참

    -- EX. 30번 부서 급여들 중 하나만이라도 큰 경우(=30번 부서 최소급여보다 큰 경우)
SELECT SAL FROM EMP WHERE DEPTNO=30;
SELECT *
    FROM EMP
    WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);

    -- 위의 QUERY를 단일행 서브쿼리로
SELECT * FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30);



-- (4) EXISTS : 서브쿼리 결과가 존재하면 참
    -- EX. 직속부하가 있는 직원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL
    FROM EMP MANAGER
    WHERE EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR);

SELECT DISTINCT M.EMPNO, M.ENAME, M.SAL
    FROM EMP W, EMP M
    WHERE W.MGR=M.EMPNO;
    
    -- EX. 말단 사원의 모든 필드 출력
SELECT *
    FROM EMP MANAGER
    WHERE NOT EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR); -- 서브쿼리 이용
    
SELECT M.*
    FROM EMP W, EMP M
    WHERE W.MGR(+)=M.EMPNO AND W.ENAME IS NULL; --SELF JOIN 이용


-- 탄탄1. 부서별로 가장 급여를 많이 받는 사원의 정보(사원 번호, 이름, 급여, 부서번호)를 출력(IN 연산자 활용)
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO; -- 서브쿼리
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP
    WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO); --메인 쿼리
    

-- 탄탄2. 직급(JOB)이 MANAGER인 사람이 속한 부서의 부서번호, 부서명, 지역을 출력(IN)
SELECT DEPTNO FROM EMP WHERE JOB='MANAGER';
SELECT DEPTNO, DNAME, LOC
    FROM DEPT
    WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB='MANAGER'); 

-- 탄탄3.급여가 3000이상인 사람들 중 급여 등급을 나눠 해당 등급별 최고 급여를 받는 사람들의
-- 사번, 이름, 직업, 입사일, 급여, 급여등급을 출력
SELECT * FROM SALGRADE;

SELECT ENAME FROM EMP WHERE SAL>=3000;
SELECT EMPNO, ENAME, JOB, HIREDATE, SAL, GRADE
    FROM EMP, SALGRADE
    WHERE SAL BETWEEN LOSAL AND HISAL
    AND SAL = HISAL;
    AND ENAME IN (SELECT ENAME FROM EMP WHERE SAL>=3000);


SELECT GRADE, MAX(SAL)
    FROM SALGRADE, EMP
    WHERE SAL BETWEEN LOSAL AND HISAL AND SAL>=3000
    GROUP BY GRADE; --서브쿼리 4,5등급
    
SELECT EMPNO, ENAME, JOB, HIREDATE, SAL, GRADE
    FROM SALGRADE, EMP
    WHERE SAL BETWEEN LOSAL AND HISAL
        AND (GRADE, SAL) IN (SELECT GRADE, MAX(SAL)
                             FROM SALGRADE, EMP
                             WHERE SAL BETWEEN LOSAL AND HISAL AND SAL>=3000
                             GROUP BY GRADE);

-- 탄탄4. 응용심화 : 입사일 분기별로 가장 높은 급여를 받는 사람들의
-- 분기, 사번, 이름, JOB, 상사사번, 입사일, 급여, 상여를 출력하세요
SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) "QUARTER", MAX(SAL) FROM EMP GROUP BY CEIL(EXTRACT(MONTH FROM HIREDATE)/3); --서브쿼리
SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) "QUARTER", EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, NVL(COMM,0)
    FROM EMP
    WHERE (CEIL(EXTRACT(MONTH FROM HIREDATE)/3), SAL) IN
            (SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) "QUARTER", MAX(SAL)
             FROM EMP GROUP BY CEIL(EXTRACT(MONTH FROM HIREDATE)/3))
    ORDER BY "QUARTER";


-- 탄탄5. JOB이 SALESMAN인 사원들보다 급여를 많이 받는 사람들의 이름, 급여, 직급(담당업무)를 출력. 단, 영업사원은 출력 X
SELECT SAL FROM EMP WHERE JOB='SALESMAN'; -- 서브쿼리(다중행)
SELECT ENAME, SAL, JOB
    FROM EMP
    WHERE SAL > ALL(SELECT SAL FROM EMP WHERE JOB='SALESMAN')
    ORDER BY SAL; --메인쿼리
    
SELECT ENAME, SAL, JOB
    FROM EMP
    WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN')
    ORDER BY SAL; --단일행으로 했을 때


-- 탄탄6. SALESMAN 사원들 어떤 한 사람보다 급여를 많이 받는 사원들의 이름과 급여와 직급을 출력. 단, 영업사원은 출력X
SELECT SAL FROM EMP WHERE JOB='SALESMAN'; -- 서브쿼리(다중행)
SSELECT ENAME, SAL, JOB
    FROM EMP
    WHERE SAL > ANY(SELECT SAL FROM EMP WHERE JOB='SALESMAN')
    ORDER BY SAL; --메인쿼리


-- 탄탄7. 연봉이 3000미만인 사람들 중 가장 최근 입사자의 사원번호, 이름, 연봉, 입사일 출력
SELECT MAX(HIREDATE) FROM EMP WHERE SAL<3000;
SELECT EMPNO, ENAME, SAL, HIREDATE
    FROM EMP
    WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP WHERE SAL<3000);


-- 탄탄8. 직급이 'SALESMAN'인 사원이 받는 최소급여보다 많이 받는 사원들의 이름, 급여, 직급, 부서번호. 단,20번부서 사원 제외(ANY 연산자 이용)
SELECT SAL FROM EMP WHERE JOB='SALESMAN';
SELECT ENAME, SAL, JOB, DEPTNO
    FROM EMP
    WHERE SAL > ANY( SELECT SAL FROM EMP WHERE JOB='SALESMAN')
    AND DEPTNO!=20
    ORDER BY DEPTNO, SAL;





-- 여기서부터는 다중행서브쿼리와 단일행서브쿼리, 이전은 단일행서브쿼리
-- 14.  이름에 “T”가 있는 사원이 근무하는 부서에서 근무하는 모든 직원의 사원 번호,이름,급여(단 사번 순 출력)
SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%';
SELECT EMPNO, ENAME, SAL
    FROM EMP
    WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%')
    ORDER BY EMPNO;
    
-- 15. 부서 위치가 Dallas인 모든 종업원에 대해 이름,업무,급여
SELECT ENAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='DALLAS';
SELECT ENAME, JOB, SAL
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND ENAME IN (SELECT ENAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='DALLAS');

-- 16. EMP 테이블에서 King에게 보고하는 모든 사원의 이름과 급여
SELECT W.ENAME FROM EMP W, EMP M WHERE W.MGR=M.EMPNO AND M.ENAME='KING';
SELECT W.ENAME, W.SAL
    FROM EMP W, EMP M
    WHERE W.MGR=M.EMPNO
    AND W.ENAME IN (SELECT W.ENAME FROM EMP W, EMP M WHERE W.MGR=M.EMPNO AND M.ENAME='KING');

-- 17. SALES부서 사원의 이름, 업무
SELECT DNAME FROM DEPT WHERE DNAME='SALES';
SELECT ENAME, JOB
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND DNAME = (SELECT DNAME FROM DEPT WHERE DNAME='SALES');

-- 18. 월급이 부서 30의 최저 월급보다 높은 사원의 모든 필드
SELECT SAL FROM EMP WHERE DEPTNO=30;
SELECT *
    FROM EMP
    WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);

-- 19. 부서 10에서 부서 30의 사원과 같은 업무를 맡고 있는 사원의 이름과 업무
SELECT JOB FROM EMP WHERE DEPTNO=30;
SELECT ENAME, JOB
    FROM EMP
    WHERE JOB IN (SELECT JOB FROM EMP WHERE DEPTNO=30)
    AND DEPTNO=10;

-- 20.  FORD와 업무도 월급도 같은 사원의 모든 필드
SELECT JOB, SAL FROM EMP WHERE ENAME='FORD';
SELECT *
    FROM EMP
    WHERE (JOB, SAL) = (SELECT JOB, SAL FROM EMP WHERE ENAME='FORD') AND ENAME!='FORD';


-- 21. 이름이 JONES인 직원의 JOB과 같거나 FORD의 SAL 이상을 받는 사원의 정보를 이름, 업무, 부서번호, 급여
    -- 단, 업무별 알파벳 순, 월급이 많은 순으로 출력
SELECT JOB FROM EMP WHERE ENAME='JONES';
SELECT SAL FROM EMP WHERE ENAME='FORD';
SELECT ENAME, JOB, DEPTNO, SAL
    FROM EMP
    WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME='JONES')
    OR SAL > (SELECT SAL FROM EMP WHERE ENAME='FORD')
    ORDER BY JOB, SAL;


-- 22. SCOTT 또는 WARD와 월급이 같은 사원의 정보를 이름,업무,급여
SELECT SAL FROM EMP WHERE ENAME='SCOTT' OR ENAME='WARD';
SELECT ENAME, JOB, SAL
    FROM EMP
    WHERE SAL IN (SELECT SAL FROM EMP WHERE ENAME='SCOTT' OR ENAME='WARD')
    AND ENAME NOT IN('SCOTT', 'WARD');


-- 23. CHICAGO에서 근무하는 사원과 같은 업무를 하는 사원들의 이름,업무
SELECT JOB FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';
SELECT ENAME, JOB
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND JOB IN (SELECT JOB FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO');

-- 24. 부서별로 월급이 평균 월급보다 높은 사원을 사번, 이름, 급여, 부서번호
-- 정답
SELECT EMPNO, ENAME, SAL
    FROM EMP E
    WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO)
    ORDER BY DEPTNO;

-- FROM절에 서브쿼리를 넣어서 하는 방법
SELECT EMPNO, ENAME, SAL
    FROM EMP E, (SELECT DEPTNO, AVG(SAL) "AVG" FROM EMP GROUP BY DEPTNO) A
    WHERE E.DEPTNO=A.DEPTNO AND SAL>AVG; --인라인뷰

-- 해당부서평균보다 높은 사원의 사번, 이름, 급여, 부서번호, 해당부서의 평균(소수점2자리)
SELECT EMPNO, ENAME, SAL, DEPTNO, ROUND((SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO),2) "AVG"
    FROM EMP E
    WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO);

-- 인라인뷰를 활용한 방법
SELECT EMPNO, ENAME, SAL, E.DEPTNO, AVG
    FROM EMP E, (SELECT DEPTNO, AVG(SAL) AVG FROM EMP GROUP BY DEPTNO) A
    WHERE E.DEPTNO=A.DEPTNO AND SAL > AVG;

-- 내가한 답
SELECT EMPNO, ENAME, SAL, DEPTNO
    FROM EMP E
    WHERE SAL > (SELECT AVG(SAL) FROM EMP T WHERE T.DEPTNO=E.DEPTNO)
    ORDER BY DEPTNO;



-- 부차적으로 해본 것
SELECT *
    FROM EMP E, EMP T
    WHERE E.DEPTNO=T.DEPTNO
    ORDER BY E.ENAME;
    
SELECT DEPTNO, COUNT(*)
    FROM EMP
    GROUP BY DEPTNO;

-- 25. 업무별로 평균 월급보다 적은 월급을 받는 사원을 부서번호, 이름, 급여
SELECT DEPTNO, ENAME, SAL, JOB
    FROM EMP E
    WHERE SAL < (SELECT AVG(SAL) FROM EMP T WHERE T.JOB=E.JOB)
    ORDER BY DEPTNO; 

-- 부차적으로 해본 것
SELECT *
    FROM EMP E, EMP T
    WHERE E.JOB=T.JOB;


-- 26. 적어도 한 명 이상으로부터 보고를 받을 수 있는 사원을 업무, 이름, 사번, 부서번호를 출력(단, 부서번호 순으로 오름차순 정렬)
SELECT JOB, ENAME, EMPNO, DEPTNO
    FROM EMP M
    WHERE EXISTS(SELECT * FROM EMP WHERE MGR=M.EMPNO)
    ORDER BY DEPTNO;


-- 27.  말단 사원의 사번, 이름, 업무, 부서번호
SELECT EMPNO, ENAME, JOB, DEPTNO
    FROM EMP M
    WHERE NOT EXISTS(SELECT * FROM EMP WHERE MGR=M.EMPNO)
    ORDER BY DEPTNO;




-- (4) EXISTS : 서브쿼리 결과가 존재하면 참
    -- EX. 직속부하가 있는 직원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL
    FROM EMP MANAGER
    WHERE EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR);

SELECT DISTINCT M.EMPNO, M.ENAME, M.SAL
    FROM EMP W, EMP M
    WHERE W.MGR=M.EMPNO;
    
    -- EX. 말단 사원의 모든 필드 출력
SELECT *
    FROM EMP MANAGER
    WHERE NOT EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR); -- 서브쿼리 이용
    
SELECT M.*
    FROM EMP W, EMP M
    WHERE W.MGR(+)=M.EMPNO AND W.ENAME IS NULL; --SELF JOIN 이용