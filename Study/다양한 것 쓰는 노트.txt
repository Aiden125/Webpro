??
ch09 예제5에서 맘파우치와 차일드 클래스를 왜 구분 했었는지?
+스태틱이 없는 버전으로 해보기

??
ch10 예제4번에서 결과창 하나씩 돌리는법?

??
추상클래스와 인터페이스 언제 나눠써야 좋을까?

??
챕터 11 - 스토어
몇호점 인지 불러오는 원리

??
디폴트 생성자가 아닌, 매개변수 있는 생성자를 바로
실행하게 하는게 뭐였는지?

??
싱글톤의 개념

??
챕터 11-shape
this.getClass();를 왜 써야되는지.

??
챕터 11-racktangle, triangle
여기서 왜 디폴트 생성자가 필수인지. circle은 필수가 아닌데 -> 해결(필수 아니었음)


++
챕터10 예제 14번 혼자 해보기
-> 여기서 String.format 안쓰고 하는 방법

++
API자주 쓰는 함수(메소드)들 정리해놓기

API의 경우 java.lang에 있고 이 클래스는 가장 시조격인 클래스이기에
여기서 가져다 쓰는건 import필요x(ex: Math.())


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
clone(복제)
3D 공간의 좌표값(x,y,z)을 갖는 Point3D 클래스를 다음의 조건에 맞게 구현하시오
①매개변수를 갖지 않는 생성자 호출시 (x=0.0, y=0.0, z=0.0)
매개변수 3개를 갖는 생성자 호출시  (x,y,z) 값으로
②x,y,z 실수의 좌표값이 같으면 true 값을 리턴하고 
그렇지 않으면 false를 리턴하는 equals() 재정의
③좌표값 [x값, y값, z값]을 리턴하는 toString() 재정의
④똑 같은 좌표객체를 복사하는 clone() 재정의
⑤위의 네 조건을 모두 보여주는 main()함수를 구현하세요

1. 데이터, 생성자(매개변수 없는거 1개, 매개변수 있는거 1개)
2. toString, equals 오버라이드 ----> 안보고 할 수 있을 정도로 알아두기
3. Cloneable 임플리먼츠 추가.
4. clone 메소드 오버라이드
5. 메인으로 넘어가서 작성-->메인에서 클론 작성하는법 제대로 알아두기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


인스턴스를 복제하고 싶은 경우 원하는 클래스에
Clonable 인터페이스를 구현해줘야함(오브젝트에 있는 객체)
+clone메소드 오버라이드

api
toString, equals 오버라이드 하는거 확실히 알아두기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
배열과 확장for문 일반for문이 같이 나온 경우.
HeadQuarterStore[] store = {
new Store1("= = = 1호점 = = ="),
new Store2("= = = 2호점 = = ="),
new Store3("= = = 3호점 = = =")};

//일반 for문
for(int idx=0 ; idx<store.length ; idx++) {
System.out.println(store[idx].getStr());
store[idx].kimchi();
store[idx].bude();
store[idx].bibib();
store[idx].sunde();
store[idx].gonggibab();
}

//확장 for문이 가독성이 더 높은 편. st는 임의 변수 지정
for(HeadQuarterStore st : store) {
System.out.println(st.getStr());
st.kimchi();
st.bude();
st.bibib();
st.sunde();
st.gonggibab();
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
배열의 두가지 방식과 for문 및 확장for문 기본형식

1. 첫번째 배열식
Personinfo p1 = new Personinfo("홍길동", 23, 'm');
Personinfo p2 = new Personinfo("홍길동", 53, 'f');

2. 두번째 배열식
Personinfo[] person = new Personinfo[2];
person[0] = new Personinfo("홍길동", 22, 'm');
person[1] = new Personinfo("홍길식", 26, 'f');

3. 배열 정의.
int[ ] arr = new int[ 2 ];
Personinfo[ ] person = { p1, p2 };

4.일반 for문
for(int idx=0 ; idx<person.length ; idx++) {
person[idx].print( );
}

5. 확장 for문
for(Personinfo p : person) {
p.print();
}

6.프린트 메소드
public void print() {
System.out.printf("이름=%s, 나이=%d, 성별=%c\n", name, age, gender);
}

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
배열의 단점
1. 크기고정
2. 정렬
3. 중복

상속에 대하여
1. 자식이 자식에게 점프(자식 클래스 = new 자식 클래스)
ChildClass child = new ChildClass();
child.getMamiName();
child.getPapaName();
child.getChildName();
System.out.println(child.pStr);
System.out.println(child.cStr);
부모 클래스의 모든것 + 자식클래스의 모든 것 이용가능

2. 부모가 부모에게 점프(부모 클래스 = new 부모 클래스)
ParentClass p = new ParentClass();
부모의 것만 이용가능. 특이한 점 x

3. 자식클래스가 부모 클래스에게 점프(부모 클래스 = new 자식 클래스)
ParentClass a = new ChildClass();
a.getMamiName();
a.getPapaName();
부모가 가진 것만 이용가능함.
자식의 권한으로 부모에게 접근한다 생각하면 될듯

4. 부모클래스가 자식클래스에게 점프는 불가
ChildClass b = new ParentClass();

정규표현식(regex)
1. 참조 : https://goo.gl/HLntbd

2. 간략 문법
\d (숫자와 매치, [0-9]와 동일)

접근제한자
priavte = 같은 클래스내에서
default = 같은 패키지내에서
protected = 같은 패키지 + 상속
public = 모두

홀짝관련
홀 수 짝수 나오면 2로 나눴을 때 나눈값이 1이냐 0이냐로 구분

일반적인 코드 구성 순서
데이터 / 생성자 / 메소드 / 오버라이드 / 게터세터 순으로 구성



자주 쓸만한 단축키
ctrl+/ = 주석처리
ctrl+shift
ctrl+shift+o = import 전체폴더 삽입